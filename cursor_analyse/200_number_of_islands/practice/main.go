package main

import (
	"fmt"
	"strings"
)

/*
题目：岛屿数量
难度：中等
标签：深度优先搜索、广度优先搜索、并查集、数组、矩阵

题目描述：
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。

要求：
- 时间复杂度：O(m*n)，其中 m 和 n 分别是网格的行数和列数
- 空间复杂度：O(m*n)，最坏情况下整个网格都是陆地

示例：
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1

输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3

提示：
1. 岛屿的定义：被水包围的连通陆地
2. 可以使用DFS或BFS来标记整个岛屿
3. 访问过的陆地要标记，避免重复计算
4. 注意边界检查，防止数组越界
5. 可以使用方向数组简化四个方向的遍历
*/

// TODO: 在这里实现你的算法
func numIslands(grid [][]byte) int {
	// 请实现你的代码
	return 0
}

// 测试用例结构
type TestCase struct {
	grid   [][]byte
	expect int
}

func main() {
	// 测试用例
	testCases := []TestCase{
		// 基本测试用例
		{
			[][]byte{
				{'1', '1', '1', '1', '0'},
				{'1', '1', '0', '1', '0'},
				{'1', '1', '0', '0', '0'},
				{'0', '0', '0', '0', '0'},
			},
			1, // 一个岛屿
		},
		{
			[][]byte{
				{'1', '1', '0', '0', '0'},
				{'1', '1', '0', '0', '0'},
				{'0', '0', '1', '0', '0'},
				{'0', '0', '0', '1', '1'},
			},
			3, // 三个岛屿
		},

		// 边界测试用例
		{
			[][]byte{
				{'1'},
			},
			1, // 单个陆地
		},
		{
			[][]byte{
				{'0'},
			},
			0, // 单个水域
		},
		{
			[][]byte{},
			0, // 空网格
		},
		{
			[][]byte{{}},
			0, // 空行
		},

		// 特殊情况测试用例
		{
			[][]byte{
				{'1', '1', '1'},
				{'0', '1', '0'},
				{'1', '1', '1'},
			},
			1, // 环形岛屿
		},
		{
			[][]byte{
				{'1', '1', '1', '1', '1'},
				{'1', '1', '1', '1', '1'},
				{'1', '1', '1', '1', '1'},
				{'1', '1', '1', '1', '1'},
			},
			1, // 全部是陆地
		},
		{
			[][]byte{
				{'0', '0', '0', '0', '0'},
				{'0', '0', '0', '0', '0'},
				{'0', '0', '0', '0', '0'},
				{'0', '0', '0', '0', '0'},
			},
			0, // 全部是水域
		},
		{
			[][]byte{
				{'1', '0', '1', '0', '1'},
				{'0', '1', '0', '1', '0'},
				{'1', '0', '1', '0', '1'},
				{'0', '1', '0', '1', '0'},
			},
			8, // 多个小岛屿
		},
	}

	fmt.Println("开始测试岛屿数量...")
	fmt.Println(strings.Repeat("=", 50))

	passed := 0
	total := len(testCases)

	for i, tc := range testCases {
		fmt.Printf("\n测试用例 %d:\n", i+1)
		fmt.Printf("输入网格:\n")
		printGrid(tc.grid)

		result := numIslands(tc.grid)

		fmt.Printf("输出: %d\n", result)
		fmt.Printf("期望: %d\n", tc.expect)

		if result == tc.expect {
			fmt.Printf("✅ 通过\n")
			passed++
		} else {
			fmt.Printf("❌ 失败\n")
		}
	}

	fmt.Println("\n" + strings.Repeat("=", 50))
	fmt.Printf("测试结果: %d/%d 通过\n", passed, total)

	if passed == total {
		fmt.Println("🎉 所有测试用例都通过了！")
	} else {
		fmt.Println("💡 还有一些测试用例没有通过，请检查你的实现。")
	}
}

// 打印网格的辅助函数
func printGrid(grid [][]byte) {
	if len(grid) == 0 {
		fmt.Println("[]")
		return
	}

	for _, row := range grid {
		fmt.Print("[")
		for j, cell := range row {
			if j > 0 {
				fmt.Print(" ")
			}
			fmt.Printf("%c", cell)
		}
		fmt.Println("]")
	}
}

/*
预期输出：
开始测试岛屿数量...
==================================================

测试用例 1:
输入网格:
[1 1 1 1 0]
[1 1 0 1 0]
[1 1 0 0 0]
[0 0 0 0 0]
输出: 1
期望: 1
✅ 通过

测试用例 2:
输入网格:
[1 1 0 0 0]
[1 1 0 0 0]
[0 0 1 0 0]
[0 0 0 1 1]
输出: 3
期望: 3
✅ 通过

测试用例 3:
输入网格:
[1]
输出: 1
期望: 1
✅ 通过

测试用例 4:
输入网格:
[0]
输出: 0
期望: 0
✅ 通过

测试用例 5:
输入网格:
[]
输出: 0
期望: 0
✅ 通过

测试用例 6:
输入网格:
[]
输出: 0
期望: 0
✅ 通过

测试用例 7:
输入网格:
[1 1 1]
[0 1 0]
[1 1 1]
输出: 1
期望: 1
✅ 通过

测试用例 8:
输入网格:
[1 1 1 1 1]
[1 1 1 1 1]
[1 1 1 1 1]
[1 1 1 1 1]
输出: 1
期望: 1
✅ 通过

测试用例 9:
输入网格:
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
输出: 0
期望: 0
✅ 通过

测试用例 10:
输入网格:
[1 0 1 0 1]
[0 1 0 1 0]
[1 0 1 0 1]
[0 1 0 1 0]
输出: 8
期望: 8
✅ 通过

==================================================
测试结果: 10/10 通过
🎉 所有测试用例都通过了！
*/
