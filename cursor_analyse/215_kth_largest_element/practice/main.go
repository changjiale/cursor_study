package main

import (
	"fmt"
)

/*
题目：数组中的第K个最大元素
难度：中等
标签：数组、分治、快速选择、排序、堆

题目描述：
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

要求：
1. 返回第k个最大的元素
2. 可以使用排序、堆、快速选择等算法
3. 注意处理边界情况

示例：
输入: nums = [3,2,1,5,6,4], k = 2
输出: 5

输入: nums = [3,2,3,1,2,4,5,5,6], k = 4
输出: 4

输入: nums = [1], k = 1
输出: 1

提示：
- 可以使用快速选择算法（平均O(n)）
- 也可以使用堆排序（O(nlogk)）
- 最简单的解法是排序后取第k个
*/

// TODO: 在这里实现你的算法
func findKthLargest(nums []int, k int) int {
	// 请实现你的代码
	return 0
}

func main() {
	// 测试用例
	testCases := []struct {
		nums []int
		k    int
		want int
	}{
		{[]int{3, 2, 1, 5, 6, 4}, 2, 5},              // 普通情况
		{[]int{3, 2, 3, 1, 2, 4, 5, 5, 6}, 4, 4},     // 包含重复元素
		{[]int{1}, 1, 1},                             // 单个元素
		{[]int{1, 2, 3, 4, 5}, 1, 5},                 // 第1大
		{[]int{1, 2, 3, 4, 5}, 5, 1},                 // 第5大
		{[]int{5, 5, 5, 5, 5}, 3, 5},                 // 全相同元素
		{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 3, 8}, // 有序数组
		{[]int{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}, 3, 8}, // 逆序数组
		{[]int{1, 1, 1, 2, 2, 3}, 2, 2},              // 重复元素
		{[]int{1, 1, 1, 1, 1, 1}, 1, 1},              // 全相同
	}

	for _, tc := range testCases {
		fmt.Printf("\n输入: nums = %v, k = %d\n", tc.nums, tc.k)
		result := findKthLargest(tc.nums, tc.k)
		fmt.Printf("输出: %d\n", result)
		fmt.Printf("期望: %d\n", tc.want)
		if result == tc.want {
			fmt.Println("✓ 通过")
		} else {
			fmt.Println("✗ 失败")
		}
	}
}

/*
预期输出：
输入: nums = [3 2 1 5 6 4], k = 2
输出: 5
期望: 5
✓ 通过

输入: nums = [3 2 3 1 2 4 5 5 6], k = 4
输出: 4
期望: 4
✓ 通过

输入: nums = [1], k = 1
输出: 1
期望: 1
✓ 通过

输入: nums = [1 2 3 4 5], k = 1
输出: 5
期望: 5
✓ 通过

输入: nums = [1 2 3 4 5], k = 5
输出: 1
期望: 1
✓ 通过

输入: nums = [5 5 5 5 5], k = 3
输出: 5
期望: 5
✓ 通过

输入: nums = [1 2 3 4 5 6 7 8 9 10], k = 3
输出: 8
期望: 8
✓ 通过

输入: nums = [10 9 8 7 6 5 4 3 2 1], k = 3
输出: 8
期望: 8
✓ 通过

输入: nums = [1 1 1 2 2 3], k = 2
输出: 2
期望: 2
✓ 通过

输入: nums = [1 1 1 1 1 1], k = 1
输出: 1
期望: 1
✓ 通过
*/
