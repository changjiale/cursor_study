package main

import (
	"fmt"
	"strings"
)

/*
题目：全排列
难度：中等
标签：数组、回溯算法

题目描述：
给定一个不含重复数字的数组 nums，返回其所有可能的全排列。你可以按任意顺序返回答案。

要求：
- 时间复杂度：O(n!)，其中 n 是数组长度
- 空间复杂度：O(n)，递归栈深度

示例：
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

输入：nums = [0,1]
输出：[[0,1],[1,0]]

输入：nums = [1]
输出：[[1]]

提示：
1. 回溯算法的核心是递归和状态恢复
2. 使用一个标记数组记录哪些数字已经被使用
3. 当路径长度等于数组长度时，找到一个排列
4. 注意数组的深拷贝，避免修改原数组
5. 回溯时要恢复状态，尝试其他选择
*/

// TODO: 在这里实现你的算法
func permute(nums []int) [][]int {
	// 请实现你的代码
	return [][]int{}
}

// 测试用例结构
type TestCase struct {
	nums   []int
	expect [][]int
}

func main() {
	// 测试用例
	testCases := []TestCase{
		// 基本测试用例
		{
			[]int{1, 2, 3},
			[][]int{
				{1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1},
			},
		},
		{
			[]int{0, 1},
			[][]int{{0, 1}, {1, 0}},
		},
		{
			[]int{1},
			[][]int{{1}},
		},

		// 边界测试用例
		{
			[]int{},
			[][]int{},
		},
		{
			[]int{1, 2},
			[][]int{{1, 2}, {2, 1}},
		},
		{
			[]int{1, 2, 3, 4},
			[][]int{
				{1, 2, 3, 4}, {1, 2, 4, 3}, {1, 3, 2, 4}, {1, 3, 4, 2}, {1, 4, 2, 3}, {1, 4, 3, 2},
				{2, 1, 3, 4}, {2, 1, 4, 3}, {2, 3, 1, 4}, {2, 3, 4, 1}, {2, 4, 1, 3}, {2, 4, 3, 1},
				{3, 1, 2, 4}, {3, 1, 4, 2}, {3, 2, 1, 4}, {3, 2, 4, 1}, {3, 4, 1, 2}, {3, 4, 2, 1},
				{4, 1, 2, 3}, {4, 1, 3, 2}, {4, 2, 1, 3}, {4, 2, 3, 1}, {4, 3, 1, 2}, {4, 3, 2, 1},
			},
		},
	}

	fmt.Println("开始测试全排列...")
	fmt.Println(strings.Repeat("=", 50))

	passed := 0
	total := len(testCases)

	for i, tc := range testCases {
		fmt.Printf("\n测试用例 %d:\n", i+1)
		fmt.Printf("输入: nums = %v\n", tc.nums)

		result := permute(tc.nums)

		fmt.Printf("输出: %v\n", result)
		fmt.Printf("期望: %v\n", tc.expect)

		// 检查结果数量
		if len(result) == len(tc.expect) {
			fmt.Printf("✅ 通过 (排列数量正确: %d)\n", len(result))
			passed++
		} else {
			fmt.Printf("❌ 失败 (期望 %d 个排列，实际 %d 个)\n", len(tc.expect), len(result))
		}

		// 对于较小的测试用例，显示详细信息
		if len(tc.nums) <= 3 {
			fmt.Printf("排列详情:\n")
			for j, perm := range result {
				fmt.Printf("  %d: %v\n", j+1, perm)
			}
		}
	}

	fmt.Println("\n" + strings.Repeat("=", 50))
	fmt.Printf("测试结果: %d/%d 通过\n", passed, total)

	if passed == total {
		fmt.Println("🎉 所有测试用例都通过了！")
		fmt.Println("\n💡 提示：")
		fmt.Println("- 对于n个数字，全排列的数量是n!")
		fmt.Println("- 回溯算法是解决这类问题的经典方法")
		fmt.Println("- 注意状态恢复，避免重复使用同一个数字")
	} else {
		fmt.Println("💡 还有一些测试用例没有通过，请检查你的实现。")
	}
}

/*
预期输出：
开始测试全排列...
==================================================

测试用例 1:
输入: nums = [1 2 3]
输出: [[1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1]]
期望: [[1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1]]
✅ 通过 (排列数量正确: 6)
排列详情:
  1: [1 2 3]
  2: [1 3 2]
  3: [2 1 3]
  4: [2 3 1]
  5: [3 1 2]
  6: [3 2 1]

测试用例 2:
输入: nums = [0 1]
输出: [[0 1] [1 0]]
期望: [[0 1] [1 0]]
✅ 通过 (排列数量正确: 2)
排列详情:
  1: [0 1]
  2: [1 0]

测试用例 3:
输入: nums = [1]
输出: [[1]]
期望: [[1]]
✅ 通过 (排列数量正确: 1)
排列详情:
  1: [1]

测试用例 4:
输入: nums = []
输出: []
期望: []
✅ 通过 (排列数量正确: 0)

测试用例 5:
输入: nums = [1 2]
输出: [[1 2] [2 1]]
期望: [[1 2] [2 1]]
✅ 通过 (排列数量正确: 2)

测试用例 6:
输入: nums = [1 2 3 4]
输出: [[1 2 3 4] [1 2 4 3] ... [4 3 2 1]]
期望: [[1 2 3 4] [1 2 4 3] ... [4 3 2 1]]
✅ 通过 (排列数量正确: 24)

==================================================
测试结果: 6/6 通过
🎉 所有测试用例都通过了！

💡 提示：
- 对于n个数字，全排列的数量是n!
- 回溯算法是解决这类问题的经典方法
- 注意状态恢复，避免重复使用同一个数字
*/
