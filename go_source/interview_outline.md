# Go语言面试大纲

## 1. 并发编程 (Concurrency)

### 1.1 Goroutine
- **基础概念**：轻量级线程、调度模型
- **数据结构**：G、M、P结构体定义和字段含义
- **调度器**：GMP调度模型、工作窃取算法
- **P队列结构**：本地队列(runq)、全局队列(sched.runq)、运行中的G(runnext)
- **调度策略**：优先级策略、负载均衡策略、性能优化策略
- **面试题目**：
  - Goroutine vs 线程的区别
  - P的本地队列和全局队列有什么区别
  - 调度器如何选择下一个要运行的Goroutine
  - 工作窃取算法是如何实现的
  - Goroutine泄漏问题
  - 如何控制Goroutine数量

### 1.2 Channel
- **数据结构**：hchan结构体定义和字段含义
- **操作机制**：发送、接收、关闭的底层实现
- **缓冲机制**：有缓冲vs无缓冲channel
- **面试题目**：
  - Channel的底层实现原理
  - Channel的阻塞机制
  - 如何优雅关闭channel

### 1.3 Select
- **实现原理**：select语句的底层实现
- **随机性**：为什么select是随机的
- **面试题目**：
  - Select的底层实现
  - Select vs switch的区别

### 1.4 Context
- **数据结构**：Context接口和实现结构体
- **核心方法**：WithCancel、WithTimeout、WithValue
- **取消机制**：context tree的取消传播
- **面试题目**：
  - Context的作用和使用场景
  - Context的取消机制
  - Context vs channel的选择

### 1.5 Sync包
- **Mutex**：互斥锁的实现原理
  - 数据结构：state字段（锁状态+等待者数量）
  - 实现机制：自旋+阻塞的混合策略
  - 性能优化：饥饿模式vs正常模式
  - 面试题目：
    - Mutex的底层实现原理
    - 自旋锁vs阻塞锁的选择
    - 饥饿模式的触发条件
    - Mutex vs RWMutex的性能对比

- **RWMutex**：读写锁的实现
  - 数据结构：readerCount、readerWait、writerSem、readerSem
  - 实现机制：写优先的读写锁
  - 性能特点：读多写少场景的优势
  - 面试题目：
    - RWMutex的底层实现原理
    - 读写锁的公平性设计
    - 写饥饿问题的解决方案
    - 何时使用RWMutex vs Mutex

- **WaitGroup**：等待组的实现
  - 数据结构：state字段（计数器+waiter数量）
  - 实现机制：原子操作+信号量
  - 使用场景：等待多个goroutine完成
  - 面试题目：
    - WaitGroup的底层实现原理
    - Add()和Done()的调用顺序
    - WaitGroup的复用问题
    - WaitGroup vs Channel的选择

- **Cond**：条件变量的使用
  - 数据结构：L字段（关联的锁）
  - 实现机制：信号量+等待队列
  - 使用场景：生产者-消费者模式
  - 面试题目：
    - Cond的底层实现原理
    - Wait()、Signal()、Broadcast()的区别
    - 虚假唤醒的处理
    - Cond vs Channel的选择

- **Once**：单次执行保证
  - 数据结构：done字段（执行状态）
  - 实现机制：双重检查锁定模式
  - 使用场景：单例模式、初始化
  - 面试题目：
    - Once的底层实现原理
    - 双重检查锁定的优势
    - Once的panic处理机制
    - Once vs sync.OnceFunc的选择

- **Pool**：对象池
  - 数据结构：local数组+victim缓存
  - 实现机制：无锁设计+GC协作
  - 使用场景：减少GC压力、复用对象
  - 面试题目：
    - Pool的底层实现原理
    - local和victim的设计思想
    - Pool的GC协作机制
    - Pool vs 手动对象池的对比

- **Map**：并发安全的map
  - 数据结构：read+dirty双map设计
  - 实现机制：读写分离+延迟删除
  - 性能特点：读多写少场景优化
  - 面试题目：
    - sync.Map的底层实现原理
    - read和dirty的设计思想
    - 延迟删除的实现机制
    - sync.Map vs map+mutex的对比

- **原子操作**：atomic包
  - 基础操作：Add、Load、Store、CompareAndSwap
  - 高级操作：Value类型、指针操作
  - 内存模型：内存序、可见性保证
  - 面试题目：
    - 原子操作的底层实现
    - CompareAndSwap的应用场景
    - atomic.Value的使用限制
    - 原子操作vs锁的性能对比

### 1.6 锁使用情况分析
- **使用互斥锁的组件**：
  - **sync.Mutex**：本身就是锁，保护共享资源
  - **sync.RWMutex**：内部包含写锁，支持读写分离
  - **sync.Once**：内部包含Mutex，保护函数执行过程
  - **sync.Map**：使用Mutex保护dirty字段
  - **sync.Cond**：需要外部Mutex，保护条件检查
  - **context.cancelCtx**：使用Mutex保护内部状态
  - **Channel (hchan)**：使用mutex保护所有操作

- **不使用互斥锁的组件**：
  - **sync.WaitGroup**：使用原子操作管理计数器
  - **sync.Pool**：通过P绑定避免锁竞争
  - **原子操作 (atomic)**：直接使用CPU原子指令

- **设计思想对比**：
  - **使用锁**：复杂状态管理、goroutine调度、条件同步、资源保护
  - **不使用锁**：简单状态、无竞争设计、硬件原子性、性能优先

- **面试题目**：
  - 为什么Once需要锁而不是只用原子操作
  - Pool的无锁设计原理
  - WaitGroup为什么可以用原子操作
  - 锁vs无锁方案的选择策略
  - 性能对比和适用场景分析

## 2. 内存管理

### 2.1 内存分配
- **分配器**：mcache、mcentral、mheap
- **对象分类**：tiny、small、large对象
- **面试题目**：
  - Go内存分配策略
  - 内存碎片问题
  - 逃逸分析

### 2.2 垃圾回收
- **GC算法**：三色标记法
- **GC触发**：触发条件和时机
- **GC调优**：GC参数调优
- **面试题目**：
  - Go GC的工作原理
  - GC性能优化
  - GC vs 手动内存管理

## 3. 运行时系统

### 3.1 调度器
- **GMP模型**：Goroutine、Machine、Processor
- **P队列结构**：本地队列、全局队列、runnext字段
- **调度策略**：优先级策略、负载均衡策略、性能优化策略
- **工作窃取**：窃取算法、负载均衡、性能优化
- **调度策略**：抢占式调度、协作式调度
- **面试题目**：
  - Go调度器的工作原理
  - P的队列结构设计思想
  - 工作窃取算法的优势
  - 调度器的性能优化

### 3.2 网络轮询器
- **epoll/kqueue**：网络IO的实现
- **面试题目**：
  - Go网络IO的实现原理
  - 高并发网络编程

## 4. 标准库

### 4.1 常用包
- **time包**：时间处理和时间轮
- **net包**：网络编程
- **encoding包**：序列化
- **面试题目**：
  - 标准库的设计思想
  - 常用包的使用技巧

## 5. 语言特性

### 5.1 Map
- **基础概念**：哈希表的实现原理
- **数据结构**：hmap结构体定义和字段含义
- **哈希算法**：哈希函数和冲突解决
- **扩容机制**：负载因子、增量扩容
- **并发安全**：map的并发访问问题
- **面试题目**：
  - Map的底层实现原理
  - Map的扩容机制
  - Map的并发安全性
  - Map vs slice的性能对比

### 5.2 接口
- **接口实现**：接口的底层实现
- **空接口**：interface{}的实现
- **面试题目**：
  - 接口的设计思想
  - 接口vs抽象类

### 5.3 反射
- **反射原理**：reflect包的实现
- **性能影响**：反射的性能开销
- **面试题目**：
  - 反射的使用场景
  - 反射的性能优化

### 5.4 泛型
- **泛型实现**：Go 1.18+的泛型机制
- **类型约束**：类型约束的使用
- **面试题目**：
  - 泛型的应用场景
  - 泛型vs接口

## 6. 性能优化

### 6.1 性能分析
- **pprof**：性能分析工具
- **benchmark**：基准测试
- **面试题目**：
  - 性能分析的方法
  - 性能优化的技巧

### 6.2 并发优化
- **并发模式**：常见的并发模式
- **性能调优**：并发程序的优化
- **面试题目**：
  - 高并发系统的设计
  - 性能瓶颈的识别

## 7. 工程实践

### 7.1 项目结构
- **目录结构**：Go项目的标准结构
- **模块管理**：go modules的使用
- **面试题目**：
  - 大型项目的组织方式
  - 依赖管理的最佳实践

### 7.2 测试
- **单元测试**：testing包的使用
- **集成测试**：测试策略
- **面试题目**：
  - 测试覆盖率的重要性
  - 测试驱动开发

## 学习优先级
1. **高优先级**：并发编程、内存管理、运行时系统、Map
2. **中优先级**：标准库、语言特性
3. **低优先级**：性能优化、工程实践

## 面试准备建议
- 重点掌握核心概念的设计思想
- 准备实际应用场景的案例
- 理解性能优化的关键点
- 能够解释常见问题的解决方案 