# LeetCode Top 题目面试突击速记

## 📋 目录
1. [字符串/数组类](#字符串数组类)
2. [链表类](#链表类)
3. [树类](#树类)
4. [动态规划类](#动态规划类)
5. [回溯/搜索类](#回溯搜索类)
6. [数据结构类](#数据结构类)

---

## 🎯 字符串/数组类

### 1. L3 - 无重复字符的最长子串
**题目描述**: 给定一个字符串，找出其中不包含重复字符的最长连续子串的长度
**核心解法**: 滑动窗口 + 哈希表
**速记点**:
- 用map记录字符最后出现位置
- 遇到重复字符时，start = max(start, 重复字符位置+1)
- 窗口大小 = i - start + 1

```go
// 核心代码
if pos, exist := posMap[r]; exist {
    start = max(start, pos + 1)
}
posMap[r] = i
maxLen = max(maxLen, i - start + 1)
```

### 2. L1 - 两数之和
**题目描述**: 给定一个整数数组和一个目标值，找出数组中两个数的和等于目标值的下标
**核心解法**: 哈希表
**速记点**:
- 遍历时检查 target - nums[i] 是否在map中
- 找到就返回，没找到就加入map

```go
complement := target - num
if j, exists := numMap[complement]; exists {
    return []int{j, i}
}
numMap[num] = i
```

### 3. L15 - 三数之和
**题目描述**: 给定一个整数数组，找出所有和为0的三元组，不能包含重复的三元组
**核心解法**: 排序 + 双指针
**速记点**:
- 先排序，固定第一个数
- 用双指针找剩余两个数
- 注意去重：跳过相同元素

```go
// 去重关键
if i > 0 && nums[i] == nums[i-1] { continue }
if left < right && nums[left] == nums[left+1] { left++ }
```

### 4. L53 - 最大子数组和
**题目描述**: 给定一个整数数组，找出一个具有最大和的连续子数组，返回其最大和
**核心解法**: 动态规划/贪心
**速记点**:
- dp[i] = max(nums[i], dp[i-1] + nums[i])
- 或者用贪心：当前和为负就重新开始

```go
if currentSum < 0 {
    currentSum = nums[i]
} else {
    currentSum += nums[i]
}
```

### 5. L5 - 最长回文子串
**题目描述**: 给定一个字符串，找到其中最长的回文子串（正着读和倒着读都一样的字符串）
**核心解法**: 中心扩展法
**速记点**:
- 以每个字符为中心向两边扩展
- 考虑奇数和偶数长度回文串

```go
len1 := expandAroundCenter(s, i, i)     // 奇数
len2 := expandAroundCenter(s, i, i+1)   // 偶数
```

### 6. L33 - 搜索旋转排序数组
**题目描述**: 给定一个旋转后的有序数组（如[4,5,6,7,0,1,2]），在其中查找目标值
**核心解法**: 二分查找
**速记点**:
- 判断左半部分是否有序：nums[left] <= nums[mid]
- 根据target是否在有序区间内决定搜索方向

```go
if nums[left] <= nums[mid] {
    // 左半部分有序
    if nums[left] <= target && target < nums[mid] {
        right = mid - 1
    } else {
        left = mid + 1
    }
}
```

### 7. L88 - 合并两个有序数组
**题目描述**: 将两个有序数组合并为一个有序数组，结果存储在第一个数组中
**核心解法**: 从后往前合并
**速记点**:
- 从后往前避免覆盖nums1中的有效元素
- 最后处理nums2剩余元素

```go
for i >= 0 && j >= 0 {
    if nums1[i] > nums2[j] {
        nums1[k] = nums1[i]; i--
    } else {
        nums1[k] = nums2[j]; j--
    }
    k--
}
```

### 8. L20 - 有效的括号
**题目描述**: 判断一个只包含括号的字符串是否有效（括号匹配且顺序正确）
**核心解法**: 栈
**速记点**:
- 左括号入栈，右括号匹配栈顶
- 栈为空时遇到右括号返回false

```go
if char == '(' || char == '{' || char == '[' {
    stack = append(stack, char)
} else {
    if len(stack) == 0 || stack[len(stack)-1] != brackets[char] {
        return false
    }
    stack = stack[:len(stack)-1]
}
```

### 9. L121 - 买卖股票的最佳时机
**题目描述**: 给定股票价格数组，只能买卖一次，求最大利润
**核心解法**: 一次遍历
**速记点**:
- 记录历史最低价格
- 当前价格 - 历史最低价格 = 当前利润

```go
if prices[i] - minPrice > maxProfit {
    maxProfit = prices[i] - minPrice
}
if prices[i] < minPrice {
    minPrice = prices[i]
}
```

### 10. L54 - 螺旋矩阵
**题目描述**: 给定一个矩阵，按照顺时针螺旋顺序返回所有元素
**核心解法**: 模拟 + 方向数组
**速记点**:
- 用visited数组标记已访问
- 方向数组：右→下→左→上
- 遇到边界或已访问就转向

```go
directions := [][]int{{0,1}, {1,0}, {0,-1}, {-1,0}}
if nextRow < 0 || nextRow >= rows || visited[nextRow][nextColumn] {
    directionIndex = (directionIndex + 1) % 4
}
```

---

## 🔗 链表类

### 11. L206 - 反转链表
**题目描述**: 反转一个单链表，返回反转后的链表头节点
**核心解法**: 迭代/递归
**速记点**:
- 三个指针：prev, curr, next
- curr.Next = prev, 然后移动指针

```go
for curr != nil {
    next := curr.Next
    curr.Next = prev
    prev = curr
    curr = next
}
```

### 12. L21 - 合并两个有序链表
**题目描述**: 将两个升序链表合并为一个新的升序链表
**核心解法**: 双指针
**速记点**:
- 比较两个链表当前节点值
- 较小的加入结果链表

```go
if node1.Value <= node2.Value {
    dummy.Next = node1
    node1 = node1.Next
} else {
    dummy.Next = node2
    node2 = node2.Next
}
```

### 13. L141 - 环形链表
**题目描述**: 判断一个链表是否有环（某个节点可以通过next指针再次到达）
**核心解法**: 快慢指针
**速记点**:
- 快指针走2步，慢指针走1步
- 有环必定相遇

```go
slow := head
fast := head.Next
for slow != fast {
    if fast == nil || fast.Next == nil {
        return false
    }
    slow = slow.Next
    fast = fast.Next.Next
}
```

### 14. L160 - 相交链表
**题目描述**: 找到两个单链表的相交起始节点，如果不存在相交节点返回null
**核心解法**: 双指针
**速记点**:
- 两个指针分别遍历两个链表
- 到达末尾时交换到另一个链表头部
- 总距离相等，有交点必定相遇

```go
for ptrA != ptrB {
    if ptrA == nil {
        ptrA = headB
    } else {
        ptrA = ptrA.Next
    }
    if ptrB == nil {
        ptrB = headA
    } else {
        ptrB = ptrB.Next
    }
}
```

### 15. L19 - 删除链表的倒数第N个节点
**题目描述**: 删除链表的倒数第n个节点，并返回链表的头节点
**核心解法**: 双指针
**速记点**:
- 快指针先走n步
- 然后快慢指针同时前进
- 快指针到达末尾时，慢指针指向要删除节点的前一个

```go
for i := 0; i < n; i++ {
    fast = fast.Next
}
for fast.Next != nil {
    fast = fast.Next
    slow = slow.Next
}
slow.Next = slow.Next.Next
```

### 16. L25 - K个一组翻转链表
**题目描述**: 每k个节点一组进行翻转，如果节点总数不是k的整数倍，最后剩余的节点保持原有顺序
**核心解法**: 分组翻转
**速记点**:
- 先找到当前组的尾节点
- 翻转当前组
- 连接前后组

```go
// 找到当前组的尾节点
for i := 0; i < k; i++ {
    tail = tail.Next
    if tail == nil {
        return dummy.Next
    }
}
// 翻转当前组
head, tail = reverse(head, tail)
```

### 17. L92 - 反转链表II
**题目描述**: 反转从位置left到位置right的链表节点，返回反转后的链表
**核心解法**: 头插法
**速记点**:
- 找到反转区域的前一个节点pre
- 将cur后面的节点逐个插入到pre后面

```go
for i := 0; i < right-left; i++ {
    next := cur.Next
    cur.Next = next.Next
    next.Next = pre.Next
    pre.Next = next
}
```

---

## 🌳 树类

### 18. L102 - 二叉树的层序遍历
**题目描述**: 返回二叉树的层序遍历结果（逐层地，从左到右访问所有节点）
**核心解法**: BFS
**速记点**:
- 用队列实现层次遍历
- 记录每层节点数量

```go
for len(queue) > 0 {
    levelSize := len(queue)
    for i := 0; i < levelSize; i++ {
        node := queue[0]
        queue = queue[1:]
        // 处理当前节点
        if node.Left != nil {
            queue = append(queue, node.Left)
        }
        if node.Right != nil {
            queue = append(queue, node.Right)
        }
    }
}
```

### 19. L103 - 二叉树的锯齿形层序遍历
**题目描述**: 先从左往右，再从右往左进行下一层遍历，层与层之间交替进行
**核心解法**: BFS + 双端队列
**速记点**:
- 偶数层从左到右，奇数层从右到左
- 根据层级决定插入位置

```go
if level%2 == 0 {
    levelNodes[i] = node.Val  // 从左到右
} else {
    levelNodes[levelSize-1-i] = node.Val  // 从右到左
}
```

### 20. L236 - 二叉树的最近公共祖先
**题目描述**: 找到二叉树中两个指定节点的最近公共祖先（深度尽可能大的祖先节点）
**核心解法**: 递归
**速记点**:
- 如果root是p或q，返回root
- 递归左右子树
- 如果左右都找到，root就是LCA

```go
if root == nil || root == p || root == q {
    return root
}
left := lowestCommonAncestor(root.Left, p, q)
right := lowestCommonAncestor(root.Right, p, q)
if left != nil && right != nil {
    return root
}
if left != nil {
    return left
}
return right
```

### 21. L199 - 二叉树的右视图
**题目描述**: 想象站在树的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值
**核心解法**: BFS
**速记点**:
- 层次遍历，记录每层最后一个节点

```go
for i := 0; i < levelSize; i++ {
    node := queue[0]
    queue = queue[1:]
    if i == levelSize-1 {
        result = append(result, node.Val)
    }
}
```

### 22. L94 - 二叉树的中序遍历
**题目描述**: 返回二叉树的中序遍历结果（左→根→右的顺序）
**核心解法**: 递归/迭代
**速记点**:
- 递归：左→根→右
- 迭代：用栈模拟递归

```go
// 递归
inorderRecursive(node.Left, result)
*result = append(*result, node.Val)
inorderRecursive(node.Right, result)
```

---

## 💰 动态规划类

### 23. L53 - 最大子数组和（已在上方）
**题目描述**: 给定一个整数数组，找出一个具有最大和的连续子数组，返回其最大和
**核心解法**: 动态规划
**速记点**: dp[i] = max(nums[i], dp[i-1] + nums[i])

---

## 🔍 回溯/搜索类

### 24. L46 - 全排列
**题目描述**: 给定一个不含重复数字的数组，返回其所有可能的全排列
**核心解法**: 回溯
**速记点**:
- 用used数组标记已使用元素
- 递归尝试每个位置放每个元素

```go
for i := 0; i < len(nums); i++ {
    if !used[i] {
        used[i] = true
        path = append(path, nums[i])
        backtrack(path, used)
        path = path[:len(path)-1]
        used[i] = false
    }
}
```

### 25. L200 - 岛屿数量
**题目描述**: 给定一个由'1'（陆地）和'0'（水）组成的二维网格，计算岛屿的数量
**核心解法**: DFS/BFS
**速记点**:
- 遍历网格，遇到1就DFS标记整个岛屿
- 用visited数组或直接修改原数组

```go
var dfs func(row, col int)
dfs = func(row, col int) {
    if row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] == '0' {
        return
    }
    grid[row][col] = '0'
    dfs(row-1, col)
    dfs(row+1, col)
    dfs(row, col-1)
    dfs(row, col+1)
}
```

---

## 🏗️ 数据结构类

### 26. L146 - LRU缓存
**题目描述**: 设计和实现一个LRU（最近最少使用）缓存，支持get和put操作，时间复杂度O(1)
**核心解法**: 哈希表 + 双向链表
**速记点**:
- 用map存储key到节点的映射
- 用双向链表维护访问顺序
- 最近使用的移到头部

```go
// 移动到头部
func (l *LRUCache) move2Head(node *Node) {
    l.removeNode(node)
    l.add2Head(node)
}
```

### 27. L215 - 数组中的第K个最大元素
**题目描述**: 给定整数数组nums和整数k，返回数组中第k个最大的元素
**核心解法**: 快速选择/堆
**速记点**:
- 快速选择：基于快排分区
- 堆：维护大小为k的小顶堆

```go
// 快速选择
target := len(nums) - k
for left <= right {
    pivotIndex := partition(nums, left, right)
    if pivotIndex == target {
        return nums[pivotIndex]
    } else if pivotIndex < target {
        left = pivotIndex + 1
    } else {
        right = pivotIndex - 1
    }
}
```

---

## 🎯 面试高频考点总结

### 算法思想
1. **双指针**: L1, L15, L160, L19, L141
2. **滑动窗口**: L3
3. **二分查找**: L33
4. **动态规划**: L53
5. **回溯**: L46
6. **DFS/BFS**: L200, L102, L103, L199, L236
7. **递归**: L206, L21, L94

### 数据结构
1. **哈希表**: L1, L3, L146
2. **栈**: L20
3. **队列**: L102, L103, L199
4. **链表**: 所有链表题
5. **树**: 所有树题
6. **堆**: L215

### 时间复杂度速记
- 双指针: O(n)
- 滑动窗口: O(n)
- 二分查找: O(log n)
- 动态规划: O(n)
- 回溯: O(n!)
- DFS/BFS: O(n)
- 哈希表操作: O(1)

### 空间复杂度速记
- 双指针: O(1)
- 滑动窗口: O(min(m,n))
- 二分查找: O(1)
- 动态规划: O(n)
- 回溯: O(n)
- DFS/BFS: O(n)
- 哈希表: O(n)

---

## 🚀 面试技巧

1. **先问清楚**: 输入输出、边界条件、特殊用例
2. **先想暴力**: 再优化
3. **画图分析**: 复杂问题画图理解
4. **代码规范**: 变量命名、注释、边界检查
5. **测试用例**: 正常、边界、特殊情况
6. **复杂度分析**: 时间、空间复杂度
7. **优化思路**: 能否进一步优化

---

## 📝 快速回忆口诀

- **双指针**: 一快一慢，一左一右
- **滑动窗口**: 扩大缩小，维护状态
- **二分查找**: 有序数组，折半查找
- **动态规划**: 状态转移，最优子结构
- **回溯**: 选择撤销，深度优先
- **BFS**: 层次遍历，队列实现
- **DFS**: 深度优先，递归实现
- **哈希表**: 快速查找，空间换时间
- **栈**: 后进先出，括号匹配
- **链表**: 指针操作，注意边界 